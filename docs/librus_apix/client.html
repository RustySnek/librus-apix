<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>librus_apix.client API documentation</title>
<meta name="description" content="This module provides classes and functions for managing API tokens, handling HTTP operations, and creating client instances for interacting with the â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>librus_apix.client</code></h1>
</header>
<section id="section-intro">
<p>This module provides classes and functions for managing API tokens, handling HTTP operations, and creating client instances for interacting with the Librus API.</p>
<h2 id="classes">Classes</h2>
<ul>
<li>Token: A class to manage and store API tokens.</li>
<li>Client: A class to handle HTTP operations using tokens.</li>
</ul>
<h2 id="functions">Functions</h2>
<ul>
<li>new_client: Function to create a new instance of the Client class.</li>
</ul>
<p>Usage:</p>
<pre><code class="language-python">my_client: Client = new_client()
_token: Token = my_client.get_token(username, password) # update the client token


#Alternatively, you can use the classes directly:
my_token = Token(API_Key=&quot;your_api_key&quot;)
my_client = Client(token=my_token)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

This module provides classes and functions for managing API tokens, handling HTTP operations, and creating client instances for interacting with the Librus API.

Classes:
    - Token: A class to manage and store API tokens.
    - Client: A class to handle HTTP operations using tokens.

Functions:
    - new_client: Function to create a new instance of the Client class.

Usage:
```python
my_client: Client = new_client()
_token: Token = my_client.get_token(username, password) # update the client token


#Alternatively, you can use the classes directly:
my_token = Token(API_Key=&#34;your_api_key&#34;)
my_client = Client(token=my_token)
```
&#34;&#34;&#34;


from typing import Optional, Dict
from requests.models import Response
from requests import Session
from requests.sessions import RequestsCookieJar
from requests.utils import cookiejar_from_dict, dict_from_cookiejar
import librus_apix.urls as urls
from librus_apix.exceptions import (
    AuthorizationError,
    MaintananceError,
    TokenKeyError,
)


class Token:
    &#34;&#34;&#34;
     A class to manage and store API tokens.

    The API key should be formatted as &#34;{DZIENNIKSID}:{SDZIENNIKSID}&#34;.

    Attributes:
        API_Key (str): The combined API key.
        csrf_token (str): CSRF token for the session.
        oauth (str): OAuth token for the session.

    Methods:
        _parse_api_key(API_Key: str) -&gt; dict:
            Parses the API key and returns a dictionary with the tokens used for cookies.
        Raises:
            TokenKeyError: If the API_Key is not in the correct format.
    &#34;&#34;&#34;

    def __init__(
        self,
        API_Key: Optional[str] = None,
        dzienniks: Optional[str] = None,
        sdzienniks: Optional[str] = None,
    ):
        &#34;&#34;&#34;
        Initializes the Token object with the given API key or token parts.

        Args:
            API_Key (str, optional): The API key in the format &#39;DZIENNIKSID:SDZIENNIKSID&#39;. Defaults to None.
            dzienniks (str, optional): The first part of the API key. Defaults to None / Ignored if API_Key is passed.
            sdzienniks (str, optional): The second part of the API key. Defaults to None / Ignored if API_Key is passed.
        &#34;&#34;&#34;
        if API_Key:
            key = API_Key
        elif dzienniks and sdzienniks:
            key = f&#34;{dzienniks}:{sdzienniks}&#34;
        else:
            key = &#34;&#34;

        self.API_Key = key
        self.csrf_token = &#34;&#34;
        self.oauth = &#34;&#34;

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the API Key.

        Returns:
            str: A string representation of the API Key.
        &#34;&#34;&#34;
        return self.API_Key

    def _parse_api_key(self, API_Key: str) -&gt; dict:
        &#34;&#34;&#34;
        Parses the API Key string into a dictionary.

        The API Key string should be in the format &#39;DZIENNIKSID:SDZIENNIKSID&#39;.

        Args:
            API_Key (str): The API Key string to be parsed.

        Returns:
            dict: A dictionary containing the parsed API Key, with keys &#39;DZIENNIKSID&#39; and &#39;SDZIENNIKSID&#39;.

        Raises:
            TokenKeyError: If the API Key is not in the correct format.
        &#34;&#34;&#34;
        parts = API_Key.split(&#34;:&#34;)
        if len(parts) != 2:
            raise TokenKeyError(
                &#34;API_Key must be in the format &#39;DZIENNIKSID:SDZIENNIKSID&#39;&#34;
            )
        return {&#34;DZIENNIKSID&#34;: parts[0], &#34;SDZIENNIKSID&#34;: parts[1]}

    def access_cookies(self) -&gt; RequestsCookieJar:
        &#34;&#34;&#34;
        returns CookieJar containing authorization cookies.

        Returns:
            RequestsCookieJar: A CookieJar containing the authorization cookies generated from the parsed API Key.
        &#34;&#34;&#34;
        return cookiejar_from_dict(self._parse_api_key(self.API_Key))


class Client:
    &#34;&#34;&#34;
    A class to handle HTTP operations using the tokens.

    Attributes:
        token (Token): The Token object containing the API key and tokens.
        proxy (dict): The proxy settings for the session.
        BASE_URL (str): The base URL for the site.
        API_URL (str): The API URL.
        GRADES_URL (str): The URL for grades.
        TIMETABLE_URL (str): The URL for the timetable.
        ANNOUNCEMENTS_URL (str): The URL for announcements.
        MESSAGE_URL (str): The URL for messages.
        SEND_MESSAGE_URL (str): The URL for sending messages.
        ATTENDANCE_URL (str): The URL for attendance.
        ATTENDANCE_DETAILS_URL (str): The URL for attendance details.
        SCHEDULE_URL (str): The URL for the schedule.
        HOMEWORK_URL (str): The URL for homework.
        HOMEWORK_DETAILS_URL (str): The URL for homework details.
        INFO_URL (str): The URL for information.
        COMPLETED_LESSONS_URL (str): The URL for completed lessons.
        GATEWAY_API_ATTENDANCE (str): The URL for gateway API attendance.
        RECIPIENTS_URL (str): The URL for recipients.
        RECIPIENT_GROUPS_URL (str): The URL for recipient groups.
        cookies (RequestsCookieJar): additional cookies
        _session (Session): The requests session for making HTTP calls.

    Methods:
        refresh_oauth() -&gt; str:
            Refreshes the OAuth token then returns it.
        post(url: str, data: Dict[str, str]) -&gt; Response:
            Makes a POST request to the specified URL with the given data.
        get(url: str) -&gt; Response:
            Makes a GET request to the specified URL.
    &#34;&#34;&#34;

    def __init__(
        self,
        token: Token,
        base_url: str = urls.BASE_URL,
        api_url: str = urls.API_URL,
        grades_url: str = urls.GRADES_URL,
        timetable_url: str = urls.TIMETABLE_URL,
        announcements_url: str = urls.ANNOUNCEMENTS_URL,
        message_url: str = urls.MESSAGE_URL,
        send_message_url: str = urls.SEND_MESSAGE_URL,
        attendance_url: str = urls.ATTENDANCE_URL,
        attendance_details_url: str = urls.ATTENDANCE_DETAILS_URL,
        schedule_url: str = urls.SCHEDULE_URL,
        homework_url: str = urls.HOMEWORK_URL,
        homework_details_url: str = urls.HOMEWORK_DETAILS_URL,
        info_url: str = urls.INFO_URL,
        recipients_url: str = urls.RECIPIENTS_URL,
        recipient_groups_url: str = urls.RECIPIENT_GROUPS_URL,
        completed_lessons_url: str = urls.COMPLETED_LESSONS_URL,
        gateway_api_attendance: str = urls.GATEWAY_API_ATTENDANCE,
        refresh_oauth_url: str = urls.REFRESH_OAUTH_URL,
        proxy: Dict[str, str] = {},
        extra_cookies: RequestsCookieJar = RequestsCookieJar(),
    ):
        self.token = token
        self.proxy = proxy
        self.BASE_URL = base_url
        self.API_URL = api_url
        self.GRADES_URL = grades_url
        self.TIMETABLE_URL = timetable_url
        self.ANNOUNCEMENTS_URL = announcements_url
        self.MESSAGE_URL = message_url
        self.SEND_MESSAGE_URL = send_message_url
        self.ATTENDANCE_URL = attendance_url
        self.ATTENDANCE_DETAILS_URL = attendance_details_url
        self.SCHEDULE_URL = schedule_url
        self.HOMEWORK_URL = homework_url
        self.HOMEWORK_DETAILS_URL = homework_details_url
        self.INFO_URL = info_url
        self.COMPLETED_LESSONS_URL = completed_lessons_url
        self.GATEWAY_API_ATTENDANCE = gateway_api_attendance
        self.RECIPIENTS_URL = recipients_url
        self.RECIPIENT_GROUPS_URL = recipient_groups_url
        self.REFRESH_URL = refresh_oauth_url
        self.cookies = extra_cookies
        self._session = Session()
        &#34;&#34;&#34;
        Initializes a new instance of Client.

        Args:
            token (Token): The authentication token required for API access.
            base_url (str, optional): The base URL of the API. Defaults to urls.BASE_URL.
            api_url (str, optional): The URL of the API endpoint. Defaults to urls.API_URL.
            grades_url (str, optional): The URL of the grades endpoint. Defaults to urls.GRADES_URL.
            timetable_url (str, optional): The URL of the timetable endpoint. Defaults to urls.TIMETABLE_URL.
            announcements_url (str, optional): The URL of the announcements endpoint. Defaults to urls.ANNOUNCEMENTS_URL.
            message_url (str, optional): The URL of the message endpoint. Defaults to urls.MESSAGE_URL.
            send_message_url (str, optional): The URL of the send message endpoint. Defaults to urls.SEND_MESSAGE_URL.
            attendance_url (str, optional): The URL of the attendance endpoint. Defaults to urls.ATTENDANCE_URL.
            attendance_details_url (str, optional): The URL of the attendance details endpoint. Defaults to urls.ATTENDANCE_DETAILS_URL.
            schedule_url (str, optional): The URL of the schedule endpoint. Defaults to urls.SCHEDULE_URL.
            homework_url (str, optional): The URL of the homework endpoint. Defaults to urls.HOMEWORK_URL.
            homework_details_url (str, optional): The URL of the homework details endpoint. Defaults to urls.HOMEWORK_DETAILS_URL.
            info_url (str, optional): The URL of the info endpoint. Defaults to urls.INFO_URL.
            recipients_url (str, optional): The URL of the recipients endpoint. Defaults to urls.RECIPIENTS_URL.
            recipient_groups_url (str, optional): The URL of the recipient groups endpoint. Defaults to urls.RECIPIENT_GROUPS_URL.
            completed_lessons_url (str, optional): The URL of the completed lessons endpoint. Defaults to urls.COMPLETED_LESSONS_URL.
            gateway_api_attendance (str, optional): The URL of the gateway API attendance endpoint. Defaults to urls.GATEWAY_API_ATTENDANCE.
            refresh_oauth_url (str, optional): The URL of the refresh OAuth endpoint. Defaults to urls.REFRESH_OAUTH_URL.
            proxy (Dict[str, str], optional): A dictionary containing proxy settings. Defaults to an empty dictionary.
         &#34;&#34;&#34;

    def get_token(
        self,
        username: str,
        password: str,
    ) -&gt; Token:
        &#34;&#34;&#34;
        Retrieves an authentication Token class for the provided username and password.

        Args:
            username (str): The username for authentication.
            password (str): The password for authentication.

        Returns:
            Token: An authentication token containing &#39;DZIENNIKSID&#39; and &#39;SDZIENNIKSID&#39; cookies.

        Raises:
            MaintananceError: If the API returns a maintenance status code or message.
            AuthorizationError: If there is an error during the authorization process.
        &#34;&#34;&#34;
        with self._session as s:
            s.headers = urls.HEADERS
            maint_check = s.get(self.API_URL, proxies=self.proxy)
            if maint_check.status_code == 503:
                message_list = maint_check.json().get(&#34;Message&#34;)
                if not message_list:
                    # during recent maintenance there were no messages (empty list)
                    raise MaintananceError(&#34;maintenance&#34;)
                raise MaintananceError(message_list[0][&#34;description&#34;])
            s.get(
                self.API_URL
                + &#34;/OAuth/Authorization?client_id=46&amp;response_type=code&amp;scope=mydata&#34;,
                proxies=self.proxy,
            )
            response = s.post(
                self.API_URL + &#34;/OAuth/Authorization?client_id=46&#34;,
                data={&#34;action&#34;: &#34;login&#34;, &#34;login&#34;: username, &#34;pass&#34;: password},
                proxies=self.proxy,
            )
            if response.json()[&#34;status&#34;] == &#34;error&#34;:
                raise AuthorizationError(response.json()[&#34;errors&#34;][0][&#34;message&#34;])

            s.get(self.API_URL + response.json().get(&#34;goTo&#34;), proxies=self.proxy)

            cookies: Dict = dict_from_cookiejar(s.cookies)
            dzienniks = cookies.get(&#34;DZIENNIKSID&#34;)
            sdzienniks = cookies.get(&#34;SDZIENNIKSID&#34;)
            if dzienniks is None or sdzienniks is None:
                raise AuthorizationError(&#34;Authorization cookies were not found&#34;)

            token = Token(dzienniks=dzienniks, sdzienniks=sdzienniks)
            self.token = token
            return token

    def refresh_oauth(self) -&gt; str:
        &#34;&#34;&#34;
        Refreshes the OAuth token.

        Returns:
            str: The new OAuth token.

        Raises:
            AuthorizationError: If the token cannot be refreshed.
        &#34;&#34;&#34;
        self.cookies.update(self.token.access_cookies())
        with self._session as s:
            s.headers = urls.HEADERS
            s.cookies = self.cookies
            response: Response = s.get(self.REFRESH_URL, proxies=self.proxy)
            if response.status_code == 200:
                oauth = response.cookies.get(&#34;oauth_token&#34;)
                self.token.oauth = oauth
                return oauth
        raise AuthorizationError(
            f&#34;Error while refreshing oauth token {response.content}&#34;
        )

    def post(self, url: str, data: Dict[str, str]) -&gt; Response:
        &#34;&#34;&#34;
        Makes a POST request to the specified URL with the given data.

        Args:
            url (str): The URL to send the POST request to.
            data (Dict[str, Union[str, int]]): The data to include in the POST request.

        Returns:
            Response: The response from the server.
        &#34;&#34;&#34;
        self.cookies.update(self.token.access_cookies())
        with self._session as s:
            s.headers = urls.HEADERS
            s.cookies = self.cookies
            response: Response = s.post(url, data=data, proxies=self.proxy)
            return response

    def get(self, url: str) -&gt; Response:
        &#34;&#34;&#34;
        Makes a GET request to the specified URL.

        Args:
            url (str): The URL to send the GET request to.

        Returns:
            Response: The response from the server.
        &#34;&#34;&#34;
        self.cookies.update(self.token.access_cookies())
        with self._session as s:
            s.headers = urls.HEADERS
            s.cookies = self.cookies
            response: Response = s.get(url, proxies=self.proxy)
            return response


def new_client(
    token: Token = Token(),
    base_url: str = urls.BASE_URL,
    api_url: str = urls.API_URL,
    grades_url: str = urls.GRADES_URL,
    timetable_url: str = urls.TIMETABLE_URL,
    announcements_url: str = urls.ANNOUNCEMENTS_URL,
    message_url: str = urls.MESSAGE_URL,
    send_message_url: str = urls.SEND_MESSAGE_URL,
    attendance_url: str = urls.ATTENDANCE_URL,
    attendance_details_url: str = urls.ATTENDANCE_DETAILS_URL,
    schedule_url: str = urls.SCHEDULE_URL,
    homework_url: str = urls.HOMEWORK_URL,
    homework_details_url: str = urls.HOMEWORK_DETAILS_URL,
    info_url: str = urls.INFO_URL,
    recipients_url: str = urls.RECIPIENTS_URL,
    recipient_groups_url: str = urls.RECIPIENT_GROUPS_URL,
    completed_lessons_url: str = urls.COMPLETED_LESSONS_URL,
    gateway_api_attendance: str = urls.GATEWAY_API_ATTENDANCE,
    refresh_oauth_url: str = urls.REFRESH_OAUTH_URL,
    proxy: dict[str, str] = {},
):
    &#34;&#34;&#34;
    Creates a new instance of the Client class.

    Args:
        token (Optional[Token], optional): The authentication token. Defaults to None.
        base_url (str, optional): The base URL of the API. Defaults to urls.BASE_URL.
        api_url (str, optional): The URL of the API endpoint. Defaults to urls.API_URL.
        grades_url (str, optional): The URL of the grades endpoint. Defaults to urls.GRADES_URL.
        timetable_url (str, optional): The URL of the timetable endpoint. Defaults to urls.TIMETABLE_URL.
        announcements_url (str, optional): The URL of the announcements endpoint. Defaults to urls.ANNOUNCEMENTS_URL.
        message_url (str, optional): The URL of the message endpoint. Defaults to urls.MESSAGE_URL.
        send_message_url (str, optional): The URL of the send message endpoint. Defaults to urls.SEND_MESSAGE_URL.
        attendance_url (str, optional): The URL of the attendance endpoint. Defaults to urls.ATTENDANCE_URL.
        attendance_details_url (str, optional): The URL of the attendance details endpoint. Defaults to urls.ATTENDANCE_DETAILS_URL.
        schedule_url (str, optional): The URL of the schedule endpoint. Defaults to urls.SCHEDULE_URL.
        homework_url (str, optional): The URL of the homework endpoint. Defaults to urls.HOMEWORK_URL.
        homework_details_url (str, optional): The URL of the homework details endpoint. Defaults to urls.HOMEWORK_DETAILS_URL.
        info_url (str, optional): The URL of the info endpoint. Defaults to urls.INFO_URL.
        recipients_url (str, optional): The URL of the recipients endpoint. Defaults to urls.RECIPIENTS_URL.
        recipient_groups_url (str, optional): The URL of the recipient groups endpoint. Defaults to urls.RECIPIENT_GROUPS_URL.
        completed_lessons_url (str, optional): The URL of the completed lessons endpoint. Defaults to urls.COMPLETED_LESSONS_URL.
        gateway_api_attendance (str, optional): The URL of the gateway API attendance endpoint. Defaults to urls.GATEWAY_API_ATTENDANCE.
        refresh_oauth_url (str, optional): The URL of the refresh OAuth endpoint. Defaults to urls.REFRESH_OAUTH_URL.
        proxy (dict[str, str], optional): A dictionary containing proxy settings. Defaults to an empty dictionary.

    Returns:
        Client: A new instance of the Client class.
    &#34;&#34;&#34;
    if not isinstance(token, Token):
        token = Token()
    return Client(
        token,
        base_url,
        api_url,
        grades_url,
        timetable_url,
        announcements_url,
        message_url,
        send_message_url,
        attendance_url,
        attendance_details_url,
        schedule_url,
        homework_url,
        homework_details_url,
        info_url,
        recipients_url,
        recipient_groups_url,
        completed_lessons_url,
        gateway_api_attendance,
        refresh_oauth_url,
        proxy,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="librus_apix.client.new_client"><code class="name flex">
<span>def <span class="ident">new_client</span></span>(<span>token:Â <a title="librus_apix.client.Token" href="#librus_apix.client.Token">Token</a>Â =Â , base_url:Â strÂ =Â 'https://synergia.librus.pl', api_url:Â strÂ =Â 'https://api.librus.pl', grades_url:Â strÂ =Â 'https://synergia.librus.pl/przegladaj_oceny/uczen', timetable_url:Â strÂ =Â 'https://synergia.librus.pl/przegladaj_plan_lekcji', announcements_url:Â strÂ =Â 'https://synergia.librus.pl/ogloszenia', message_url:Â strÂ =Â 'https://synergia.librus.pl/wiadomosci/1/5', send_message_url:Â strÂ =Â 'https://synergia.librus.pl/wiadomosci/1/6', attendance_url:Â strÂ =Â 'https://synergia.librus.pl/przegladaj_nb/uczen', attendance_details_url:Â strÂ =Â 'https://synergia.librus.pl/przegladaj_nb/szczegoly/', schedule_url:Â strÂ =Â 'https://synergia.librus.pl/terminarz/', homework_url:Â strÂ =Â 'https://synergia.librus.pl/moje_zadania', homework_details_url:Â strÂ =Â 'https://synergia.librus.pl/moje_zadania/podglad/', info_url:Â strÂ =Â 'https://synergia.librus.pl/informacja', recipients_url:Â strÂ =Â 'https://synergia.librus.pl/getRecipients', recipient_groups_url:Â strÂ =Â 'https://synergia.librus.pl/wiadomosci/2/6', completed_lessons_url:Â strÂ =Â 'https://synergia.librus.pl/zrealizowane_lekcje', gateway_api_attendance:Â strÂ =Â 'https://synergia.librus.pl/gateway/api/2.0/Attendances', refresh_oauth_url:Â strÂ =Â 'https://synergia.librus.pl/refreshToken', proxy:Â dict[str,Â str]Â =Â {})</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new instance of the Client class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code>Optional[<a title="librus_apix.client.Token" href="#librus_apix.client.Token">Token</a>]</code>, optional</dt>
<dd>The authentication token. Defaults to None.</dd>
<dt><strong><code>base_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The base URL of the API. Defaults to urls.BASE_URL.</dd>
<dt><strong><code>api_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the API endpoint. Defaults to urls.API_URL.</dd>
<dt><strong><code>grades_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the grades endpoint. Defaults to urls.GRADES_URL.</dd>
<dt><strong><code>timetable_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the timetable endpoint. Defaults to urls.TIMETABLE_URL.</dd>
<dt><strong><code>announcements_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the announcements endpoint. Defaults to urls.ANNOUNCEMENTS_URL.</dd>
<dt><strong><code>message_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the message endpoint. Defaults to urls.MESSAGE_URL.</dd>
<dt><strong><code>send_message_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the send message endpoint. Defaults to urls.SEND_MESSAGE_URL.</dd>
<dt><strong><code>attendance_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the attendance endpoint. Defaults to urls.ATTENDANCE_URL.</dd>
<dt><strong><code>attendance_details_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the attendance details endpoint. Defaults to urls.ATTENDANCE_DETAILS_URL.</dd>
<dt><strong><code>schedule_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the schedule endpoint. Defaults to urls.SCHEDULE_URL.</dd>
<dt><strong><code>homework_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the homework endpoint. Defaults to urls.HOMEWORK_URL.</dd>
<dt><strong><code>homework_details_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the homework details endpoint. Defaults to urls.HOMEWORK_DETAILS_URL.</dd>
<dt><strong><code>info_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the info endpoint. Defaults to urls.INFO_URL.</dd>
<dt><strong><code>recipients_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the recipients endpoint. Defaults to urls.RECIPIENTS_URL.</dd>
<dt><strong><code>recipient_groups_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the recipient groups endpoint. Defaults to urls.RECIPIENT_GROUPS_URL.</dd>
<dt><strong><code>completed_lessons_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the completed lessons endpoint. Defaults to urls.COMPLETED_LESSONS_URL.</dd>
<dt><strong><code>gateway_api_attendance</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the gateway API attendance endpoint. Defaults to urls.GATEWAY_API_ATTENDANCE.</dd>
<dt><strong><code>refresh_oauth_url</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The URL of the refresh OAuth endpoint. Defaults to urls.REFRESH_OAUTH_URL.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>dict[str, str]</code>, optional</dt>
<dd>A dictionary containing proxy settings. Defaults to an empty dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="librus_apix.client.Client" href="#librus_apix.client.Client">Client</a></code></dt>
<dd>A new instance of the Client class.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_client(
    token: Token = Token(),
    base_url: str = urls.BASE_URL,
    api_url: str = urls.API_URL,
    grades_url: str = urls.GRADES_URL,
    timetable_url: str = urls.TIMETABLE_URL,
    announcements_url: str = urls.ANNOUNCEMENTS_URL,
    message_url: str = urls.MESSAGE_URL,
    send_message_url: str = urls.SEND_MESSAGE_URL,
    attendance_url: str = urls.ATTENDANCE_URL,
    attendance_details_url: str = urls.ATTENDANCE_DETAILS_URL,
    schedule_url: str = urls.SCHEDULE_URL,
    homework_url: str = urls.HOMEWORK_URL,
    homework_details_url: str = urls.HOMEWORK_DETAILS_URL,
    info_url: str = urls.INFO_URL,
    recipients_url: str = urls.RECIPIENTS_URL,
    recipient_groups_url: str = urls.RECIPIENT_GROUPS_URL,
    completed_lessons_url: str = urls.COMPLETED_LESSONS_URL,
    gateway_api_attendance: str = urls.GATEWAY_API_ATTENDANCE,
    refresh_oauth_url: str = urls.REFRESH_OAUTH_URL,
    proxy: dict[str, str] = {},
):
    &#34;&#34;&#34;
    Creates a new instance of the Client class.

    Args:
        token (Optional[Token], optional): The authentication token. Defaults to None.
        base_url (str, optional): The base URL of the API. Defaults to urls.BASE_URL.
        api_url (str, optional): The URL of the API endpoint. Defaults to urls.API_URL.
        grades_url (str, optional): The URL of the grades endpoint. Defaults to urls.GRADES_URL.
        timetable_url (str, optional): The URL of the timetable endpoint. Defaults to urls.TIMETABLE_URL.
        announcements_url (str, optional): The URL of the announcements endpoint. Defaults to urls.ANNOUNCEMENTS_URL.
        message_url (str, optional): The URL of the message endpoint. Defaults to urls.MESSAGE_URL.
        send_message_url (str, optional): The URL of the send message endpoint. Defaults to urls.SEND_MESSAGE_URL.
        attendance_url (str, optional): The URL of the attendance endpoint. Defaults to urls.ATTENDANCE_URL.
        attendance_details_url (str, optional): The URL of the attendance details endpoint. Defaults to urls.ATTENDANCE_DETAILS_URL.
        schedule_url (str, optional): The URL of the schedule endpoint. Defaults to urls.SCHEDULE_URL.
        homework_url (str, optional): The URL of the homework endpoint. Defaults to urls.HOMEWORK_URL.
        homework_details_url (str, optional): The URL of the homework details endpoint. Defaults to urls.HOMEWORK_DETAILS_URL.
        info_url (str, optional): The URL of the info endpoint. Defaults to urls.INFO_URL.
        recipients_url (str, optional): The URL of the recipients endpoint. Defaults to urls.RECIPIENTS_URL.
        recipient_groups_url (str, optional): The URL of the recipient groups endpoint. Defaults to urls.RECIPIENT_GROUPS_URL.
        completed_lessons_url (str, optional): The URL of the completed lessons endpoint. Defaults to urls.COMPLETED_LESSONS_URL.
        gateway_api_attendance (str, optional): The URL of the gateway API attendance endpoint. Defaults to urls.GATEWAY_API_ATTENDANCE.
        refresh_oauth_url (str, optional): The URL of the refresh OAuth endpoint. Defaults to urls.REFRESH_OAUTH_URL.
        proxy (dict[str, str], optional): A dictionary containing proxy settings. Defaults to an empty dictionary.

    Returns:
        Client: A new instance of the Client class.
    &#34;&#34;&#34;
    if not isinstance(token, Token):
        token = Token()
    return Client(
        token,
        base_url,
        api_url,
        grades_url,
        timetable_url,
        announcements_url,
        message_url,
        send_message_url,
        attendance_url,
        attendance_details_url,
        schedule_url,
        homework_url,
        homework_details_url,
        info_url,
        recipients_url,
        recipient_groups_url,
        completed_lessons_url,
        gateway_api_attendance,
        refresh_oauth_url,
        proxy,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="librus_apix.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>token:Â <a title="librus_apix.client.Token" href="#librus_apix.client.Token">Token</a>, base_url:Â strÂ =Â 'https://synergia.librus.pl', api_url:Â strÂ =Â 'https://api.librus.pl', grades_url:Â strÂ =Â 'https://synergia.librus.pl/przegladaj_oceny/uczen', timetable_url:Â strÂ =Â 'https://synergia.librus.pl/przegladaj_plan_lekcji', announcements_url:Â strÂ =Â 'https://synergia.librus.pl/ogloszenia', message_url:Â strÂ =Â 'https://synergia.librus.pl/wiadomosci/1/5', send_message_url:Â strÂ =Â 'https://synergia.librus.pl/wiadomosci/1/6', attendance_url:Â strÂ =Â 'https://synergia.librus.pl/przegladaj_nb/uczen', attendance_details_url:Â strÂ =Â 'https://synergia.librus.pl/przegladaj_nb/szczegoly/', schedule_url:Â strÂ =Â 'https://synergia.librus.pl/terminarz/', homework_url:Â strÂ =Â 'https://synergia.librus.pl/moje_zadania', homework_details_url:Â strÂ =Â 'https://synergia.librus.pl/moje_zadania/podglad/', info_url:Â strÂ =Â 'https://synergia.librus.pl/informacja', recipients_url:Â strÂ =Â 'https://synergia.librus.pl/getRecipients', recipient_groups_url:Â strÂ =Â 'https://synergia.librus.pl/wiadomosci/2/6', completed_lessons_url:Â strÂ =Â 'https://synergia.librus.pl/zrealizowane_lekcje', gateway_api_attendance:Â strÂ =Â 'https://synergia.librus.pl/gateway/api/2.0/Attendances', refresh_oauth_url:Â strÂ =Â 'https://synergia.librus.pl/refreshToken', proxy:Â Dict[str,Â str]Â =Â {}, extra_cookies:Â requests.cookies.RequestsCookieJarÂ =Â &lt;RequestsCookieJar[]&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to handle HTTP operations using the tokens.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a title="librus_apix.client.Token" href="#librus_apix.client.Token">Token</a></code></dt>
<dd>The Token object containing the API key and tokens.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>dict</code></dt>
<dd>The proxy settings for the session.</dd>
<dt><strong><code>BASE_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The base URL for the site.</dd>
<dt><strong><code>API_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The API URL.</dd>
<dt><strong><code>GRADES_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for grades.</dd>
<dt><strong><code>TIMETABLE_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for the timetable.</dd>
<dt><strong><code>ANNOUNCEMENTS_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for announcements.</dd>
<dt><strong><code>MESSAGE_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for messages.</dd>
<dt><strong><code>SEND_MESSAGE_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for sending messages.</dd>
<dt><strong><code>ATTENDANCE_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for attendance.</dd>
<dt><strong><code>ATTENDANCE_DETAILS_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for attendance details.</dd>
<dt><strong><code>SCHEDULE_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for the schedule.</dd>
<dt><strong><code>HOMEWORK_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for homework.</dd>
<dt><strong><code>HOMEWORK_DETAILS_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for homework details.</dd>
<dt><strong><code>INFO_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for information.</dd>
<dt><strong><code>COMPLETED_LESSONS_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for completed lessons.</dd>
<dt><strong><code>GATEWAY_API_ATTENDANCE</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for gateway API attendance.</dd>
<dt><strong><code>RECIPIENTS_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for recipients.</dd>
<dt><strong><code>RECIPIENT_GROUPS_URL</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for recipient groups.</dd>
<dt><strong><code>cookies</code></strong> :&ensp;<code>RequestsCookieJar</code></dt>
<dd>additional cookies</dd>
<dt><strong><code>_session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The requests session for making HTTP calls.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>refresh_oauth() -&gt; str:
Refreshes the OAuth token then returns it.
post(url: str, data: Dict[str, str]) -&gt; Response:
Makes a POST request to the specified URL with the given data.
get(url: str) -&gt; Response:
Makes a GET request to the specified URL.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client:
    &#34;&#34;&#34;
    A class to handle HTTP operations using the tokens.

    Attributes:
        token (Token): The Token object containing the API key and tokens.
        proxy (dict): The proxy settings for the session.
        BASE_URL (str): The base URL for the site.
        API_URL (str): The API URL.
        GRADES_URL (str): The URL for grades.
        TIMETABLE_URL (str): The URL for the timetable.
        ANNOUNCEMENTS_URL (str): The URL for announcements.
        MESSAGE_URL (str): The URL for messages.
        SEND_MESSAGE_URL (str): The URL for sending messages.
        ATTENDANCE_URL (str): The URL for attendance.
        ATTENDANCE_DETAILS_URL (str): The URL for attendance details.
        SCHEDULE_URL (str): The URL for the schedule.
        HOMEWORK_URL (str): The URL for homework.
        HOMEWORK_DETAILS_URL (str): The URL for homework details.
        INFO_URL (str): The URL for information.
        COMPLETED_LESSONS_URL (str): The URL for completed lessons.
        GATEWAY_API_ATTENDANCE (str): The URL for gateway API attendance.
        RECIPIENTS_URL (str): The URL for recipients.
        RECIPIENT_GROUPS_URL (str): The URL for recipient groups.
        cookies (RequestsCookieJar): additional cookies
        _session (Session): The requests session for making HTTP calls.

    Methods:
        refresh_oauth() -&gt; str:
            Refreshes the OAuth token then returns it.
        post(url: str, data: Dict[str, str]) -&gt; Response:
            Makes a POST request to the specified URL with the given data.
        get(url: str) -&gt; Response:
            Makes a GET request to the specified URL.
    &#34;&#34;&#34;

    def __init__(
        self,
        token: Token,
        base_url: str = urls.BASE_URL,
        api_url: str = urls.API_URL,
        grades_url: str = urls.GRADES_URL,
        timetable_url: str = urls.TIMETABLE_URL,
        announcements_url: str = urls.ANNOUNCEMENTS_URL,
        message_url: str = urls.MESSAGE_URL,
        send_message_url: str = urls.SEND_MESSAGE_URL,
        attendance_url: str = urls.ATTENDANCE_URL,
        attendance_details_url: str = urls.ATTENDANCE_DETAILS_URL,
        schedule_url: str = urls.SCHEDULE_URL,
        homework_url: str = urls.HOMEWORK_URL,
        homework_details_url: str = urls.HOMEWORK_DETAILS_URL,
        info_url: str = urls.INFO_URL,
        recipients_url: str = urls.RECIPIENTS_URL,
        recipient_groups_url: str = urls.RECIPIENT_GROUPS_URL,
        completed_lessons_url: str = urls.COMPLETED_LESSONS_URL,
        gateway_api_attendance: str = urls.GATEWAY_API_ATTENDANCE,
        refresh_oauth_url: str = urls.REFRESH_OAUTH_URL,
        proxy: Dict[str, str] = {},
        extra_cookies: RequestsCookieJar = RequestsCookieJar(),
    ):
        self.token = token
        self.proxy = proxy
        self.BASE_URL = base_url
        self.API_URL = api_url
        self.GRADES_URL = grades_url
        self.TIMETABLE_URL = timetable_url
        self.ANNOUNCEMENTS_URL = announcements_url
        self.MESSAGE_URL = message_url
        self.SEND_MESSAGE_URL = send_message_url
        self.ATTENDANCE_URL = attendance_url
        self.ATTENDANCE_DETAILS_URL = attendance_details_url
        self.SCHEDULE_URL = schedule_url
        self.HOMEWORK_URL = homework_url
        self.HOMEWORK_DETAILS_URL = homework_details_url
        self.INFO_URL = info_url
        self.COMPLETED_LESSONS_URL = completed_lessons_url
        self.GATEWAY_API_ATTENDANCE = gateway_api_attendance
        self.RECIPIENTS_URL = recipients_url
        self.RECIPIENT_GROUPS_URL = recipient_groups_url
        self.REFRESH_URL = refresh_oauth_url
        self.cookies = extra_cookies
        self._session = Session()
        &#34;&#34;&#34;
        Initializes a new instance of Client.

        Args:
            token (Token): The authentication token required for API access.
            base_url (str, optional): The base URL of the API. Defaults to urls.BASE_URL.
            api_url (str, optional): The URL of the API endpoint. Defaults to urls.API_URL.
            grades_url (str, optional): The URL of the grades endpoint. Defaults to urls.GRADES_URL.
            timetable_url (str, optional): The URL of the timetable endpoint. Defaults to urls.TIMETABLE_URL.
            announcements_url (str, optional): The URL of the announcements endpoint. Defaults to urls.ANNOUNCEMENTS_URL.
            message_url (str, optional): The URL of the message endpoint. Defaults to urls.MESSAGE_URL.
            send_message_url (str, optional): The URL of the send message endpoint. Defaults to urls.SEND_MESSAGE_URL.
            attendance_url (str, optional): The URL of the attendance endpoint. Defaults to urls.ATTENDANCE_URL.
            attendance_details_url (str, optional): The URL of the attendance details endpoint. Defaults to urls.ATTENDANCE_DETAILS_URL.
            schedule_url (str, optional): The URL of the schedule endpoint. Defaults to urls.SCHEDULE_URL.
            homework_url (str, optional): The URL of the homework endpoint. Defaults to urls.HOMEWORK_URL.
            homework_details_url (str, optional): The URL of the homework details endpoint. Defaults to urls.HOMEWORK_DETAILS_URL.
            info_url (str, optional): The URL of the info endpoint. Defaults to urls.INFO_URL.
            recipients_url (str, optional): The URL of the recipients endpoint. Defaults to urls.RECIPIENTS_URL.
            recipient_groups_url (str, optional): The URL of the recipient groups endpoint. Defaults to urls.RECIPIENT_GROUPS_URL.
            completed_lessons_url (str, optional): The URL of the completed lessons endpoint. Defaults to urls.COMPLETED_LESSONS_URL.
            gateway_api_attendance (str, optional): The URL of the gateway API attendance endpoint. Defaults to urls.GATEWAY_API_ATTENDANCE.
            refresh_oauth_url (str, optional): The URL of the refresh OAuth endpoint. Defaults to urls.REFRESH_OAUTH_URL.
            proxy (Dict[str, str], optional): A dictionary containing proxy settings. Defaults to an empty dictionary.
         &#34;&#34;&#34;

    def get_token(
        self,
        username: str,
        password: str,
    ) -&gt; Token:
        &#34;&#34;&#34;
        Retrieves an authentication Token class for the provided username and password.

        Args:
            username (str): The username for authentication.
            password (str): The password for authentication.

        Returns:
            Token: An authentication token containing &#39;DZIENNIKSID&#39; and &#39;SDZIENNIKSID&#39; cookies.

        Raises:
            MaintananceError: If the API returns a maintenance status code or message.
            AuthorizationError: If there is an error during the authorization process.
        &#34;&#34;&#34;
        with self._session as s:
            s.headers = urls.HEADERS
            maint_check = s.get(self.API_URL, proxies=self.proxy)
            if maint_check.status_code == 503:
                message_list = maint_check.json().get(&#34;Message&#34;)
                if not message_list:
                    # during recent maintenance there were no messages (empty list)
                    raise MaintananceError(&#34;maintenance&#34;)
                raise MaintananceError(message_list[0][&#34;description&#34;])
            s.get(
                self.API_URL
                + &#34;/OAuth/Authorization?client_id=46&amp;response_type=code&amp;scope=mydata&#34;,
                proxies=self.proxy,
            )
            response = s.post(
                self.API_URL + &#34;/OAuth/Authorization?client_id=46&#34;,
                data={&#34;action&#34;: &#34;login&#34;, &#34;login&#34;: username, &#34;pass&#34;: password},
                proxies=self.proxy,
            )
            if response.json()[&#34;status&#34;] == &#34;error&#34;:
                raise AuthorizationError(response.json()[&#34;errors&#34;][0][&#34;message&#34;])

            s.get(self.API_URL + response.json().get(&#34;goTo&#34;), proxies=self.proxy)

            cookies: Dict = dict_from_cookiejar(s.cookies)
            dzienniks = cookies.get(&#34;DZIENNIKSID&#34;)
            sdzienniks = cookies.get(&#34;SDZIENNIKSID&#34;)
            if dzienniks is None or sdzienniks is None:
                raise AuthorizationError(&#34;Authorization cookies were not found&#34;)

            token = Token(dzienniks=dzienniks, sdzienniks=sdzienniks)
            self.token = token
            return token

    def refresh_oauth(self) -&gt; str:
        &#34;&#34;&#34;
        Refreshes the OAuth token.

        Returns:
            str: The new OAuth token.

        Raises:
            AuthorizationError: If the token cannot be refreshed.
        &#34;&#34;&#34;
        self.cookies.update(self.token.access_cookies())
        with self._session as s:
            s.headers = urls.HEADERS
            s.cookies = self.cookies
            response: Response = s.get(self.REFRESH_URL, proxies=self.proxy)
            if response.status_code == 200:
                oauth = response.cookies.get(&#34;oauth_token&#34;)
                self.token.oauth = oauth
                return oauth
        raise AuthorizationError(
            f&#34;Error while refreshing oauth token {response.content}&#34;
        )

    def post(self, url: str, data: Dict[str, str]) -&gt; Response:
        &#34;&#34;&#34;
        Makes a POST request to the specified URL with the given data.

        Args:
            url (str): The URL to send the POST request to.
            data (Dict[str, Union[str, int]]): The data to include in the POST request.

        Returns:
            Response: The response from the server.
        &#34;&#34;&#34;
        self.cookies.update(self.token.access_cookies())
        with self._session as s:
            s.headers = urls.HEADERS
            s.cookies = self.cookies
            response: Response = s.post(url, data=data, proxies=self.proxy)
            return response

    def get(self, url: str) -&gt; Response:
        &#34;&#34;&#34;
        Makes a GET request to the specified URL.

        Args:
            url (str): The URL to send the GET request to.

        Returns:
            Response: The response from the server.
        &#34;&#34;&#34;
        self.cookies.update(self.token.access_cookies())
        with self._session as s:
            s.headers = urls.HEADERS
            s.cookies = self.cookies
            response: Response = s.get(url, proxies=self.proxy)
            return response</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="librus_apix.client.Client.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, url:Â str) â€‘>Â requests.models.Response</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a GET request to the specified URL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL to send the GET request to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>The response from the server.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, url: str) -&gt; Response:
    &#34;&#34;&#34;
    Makes a GET request to the specified URL.

    Args:
        url (str): The URL to send the GET request to.

    Returns:
        Response: The response from the server.
    &#34;&#34;&#34;
    self.cookies.update(self.token.access_cookies())
    with self._session as s:
        s.headers = urls.HEADERS
        s.cookies = self.cookies
        response: Response = s.get(url, proxies=self.proxy)
        return response</code></pre>
</details>
</dd>
<dt id="librus_apix.client.Client.get_token"><code class="name flex">
<span>def <span class="ident">get_token</span></span>(<span>self, username:Â str, password:Â str) â€‘>Â <a title="librus_apix.client.Token" href="#librus_apix.client.Token">Token</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves an authentication Token class for the provided username and password.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The username for authentication.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The password for authentication.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="librus_apix.client.Token" href="#librus_apix.client.Token">Token</a></code></dt>
<dd>An authentication token containing 'DZIENNIKSID' and 'SDZIENNIKSID' cookies.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MaintananceError</code></dt>
<dd>If the API returns a maintenance status code or message.</dd>
<dt><code>AuthorizationError</code></dt>
<dd>If there is an error during the authorization process.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_token(
    self,
    username: str,
    password: str,
) -&gt; Token:
    &#34;&#34;&#34;
    Retrieves an authentication Token class for the provided username and password.

    Args:
        username (str): The username for authentication.
        password (str): The password for authentication.

    Returns:
        Token: An authentication token containing &#39;DZIENNIKSID&#39; and &#39;SDZIENNIKSID&#39; cookies.

    Raises:
        MaintananceError: If the API returns a maintenance status code or message.
        AuthorizationError: If there is an error during the authorization process.
    &#34;&#34;&#34;
    with self._session as s:
        s.headers = urls.HEADERS
        maint_check = s.get(self.API_URL, proxies=self.proxy)
        if maint_check.status_code == 503:
            message_list = maint_check.json().get(&#34;Message&#34;)
            if not message_list:
                # during recent maintenance there were no messages (empty list)
                raise MaintananceError(&#34;maintenance&#34;)
            raise MaintananceError(message_list[0][&#34;description&#34;])
        s.get(
            self.API_URL
            + &#34;/OAuth/Authorization?client_id=46&amp;response_type=code&amp;scope=mydata&#34;,
            proxies=self.proxy,
        )
        response = s.post(
            self.API_URL + &#34;/OAuth/Authorization?client_id=46&#34;,
            data={&#34;action&#34;: &#34;login&#34;, &#34;login&#34;: username, &#34;pass&#34;: password},
            proxies=self.proxy,
        )
        if response.json()[&#34;status&#34;] == &#34;error&#34;:
            raise AuthorizationError(response.json()[&#34;errors&#34;][0][&#34;message&#34;])

        s.get(self.API_URL + response.json().get(&#34;goTo&#34;), proxies=self.proxy)

        cookies: Dict = dict_from_cookiejar(s.cookies)
        dzienniks = cookies.get(&#34;DZIENNIKSID&#34;)
        sdzienniks = cookies.get(&#34;SDZIENNIKSID&#34;)
        if dzienniks is None or sdzienniks is None:
            raise AuthorizationError(&#34;Authorization cookies were not found&#34;)

        token = Token(dzienniks=dzienniks, sdzienniks=sdzienniks)
        self.token = token
        return token</code></pre>
</details>
</dd>
<dt id="librus_apix.client.Client.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self, url:Â str, data:Â Dict[str,Â str]) â€‘>Â requests.models.Response</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a POST request to the specified URL with the given data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL to send the POST request to.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict[str, Union[str, int]]</code></dt>
<dd>The data to include in the POST request.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>The response from the server.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post(self, url: str, data: Dict[str, str]) -&gt; Response:
    &#34;&#34;&#34;
    Makes a POST request to the specified URL with the given data.

    Args:
        url (str): The URL to send the POST request to.
        data (Dict[str, Union[str, int]]): The data to include in the POST request.

    Returns:
        Response: The response from the server.
    &#34;&#34;&#34;
    self.cookies.update(self.token.access_cookies())
    with self._session as s:
        s.headers = urls.HEADERS
        s.cookies = self.cookies
        response: Response = s.post(url, data=data, proxies=self.proxy)
        return response</code></pre>
</details>
</dd>
<dt id="librus_apix.client.Client.refresh_oauth"><code class="name flex">
<span>def <span class="ident">refresh_oauth</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Refreshes the OAuth token.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The new OAuth token.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AuthorizationError</code></dt>
<dd>If the token cannot be refreshed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_oauth(self) -&gt; str:
    &#34;&#34;&#34;
    Refreshes the OAuth token.

    Returns:
        str: The new OAuth token.

    Raises:
        AuthorizationError: If the token cannot be refreshed.
    &#34;&#34;&#34;
    self.cookies.update(self.token.access_cookies())
    with self._session as s:
        s.headers = urls.HEADERS
        s.cookies = self.cookies
        response: Response = s.get(self.REFRESH_URL, proxies=self.proxy)
        if response.status_code == 200:
            oauth = response.cookies.get(&#34;oauth_token&#34;)
            self.token.oauth = oauth
            return oauth
    raise AuthorizationError(
        f&#34;Error while refreshing oauth token {response.content}&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="librus_apix.client.Token"><code class="flex name class">
<span>class <span class="ident">Token</span></span>
<span>(</span><span>API_Key:Â Optional[str]Â =Â None, dzienniks:Â Optional[str]Â =Â None, sdzienniks:Â Optional[str]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to manage and store API tokens.</p>
<p>The API key should be formatted as "{DZIENNIKSID}:{SDZIENNIKSID}".</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>API_Key</code></strong> :&ensp;<code>str</code></dt>
<dd>The combined API key.</dd>
<dt><strong><code>csrf_token</code></strong> :&ensp;<code>str</code></dt>
<dd>CSRF token for the session.</dd>
<dt><strong><code>oauth</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth token for the session.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>_parse_api_key(API_Key: str) -&gt; dict:
Parses the API key and returns a dictionary with the tokens used for cookies.
Raises:
TokenKeyError: If the API_Key is not in the correct format.</p>
<p>Initializes the Token object with the given API key or token parts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>API_Key</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The API key in the format 'DZIENNIKSID:SDZIENNIKSID'. Defaults to None.</dd>
<dt><strong><code>dzienniks</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The first part of the API key. Defaults to None / Ignored if API_Key is passed.</dd>
<dt><strong><code>sdzienniks</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The second part of the API key. Defaults to None / Ignored if API_Key is passed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Token:
    &#34;&#34;&#34;
     A class to manage and store API tokens.

    The API key should be formatted as &#34;{DZIENNIKSID}:{SDZIENNIKSID}&#34;.

    Attributes:
        API_Key (str): The combined API key.
        csrf_token (str): CSRF token for the session.
        oauth (str): OAuth token for the session.

    Methods:
        _parse_api_key(API_Key: str) -&gt; dict:
            Parses the API key and returns a dictionary with the tokens used for cookies.
        Raises:
            TokenKeyError: If the API_Key is not in the correct format.
    &#34;&#34;&#34;

    def __init__(
        self,
        API_Key: Optional[str] = None,
        dzienniks: Optional[str] = None,
        sdzienniks: Optional[str] = None,
    ):
        &#34;&#34;&#34;
        Initializes the Token object with the given API key or token parts.

        Args:
            API_Key (str, optional): The API key in the format &#39;DZIENNIKSID:SDZIENNIKSID&#39;. Defaults to None.
            dzienniks (str, optional): The first part of the API key. Defaults to None / Ignored if API_Key is passed.
            sdzienniks (str, optional): The second part of the API key. Defaults to None / Ignored if API_Key is passed.
        &#34;&#34;&#34;
        if API_Key:
            key = API_Key
        elif dzienniks and sdzienniks:
            key = f&#34;{dzienniks}:{sdzienniks}&#34;
        else:
            key = &#34;&#34;

        self.API_Key = key
        self.csrf_token = &#34;&#34;
        self.oauth = &#34;&#34;

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the API Key.

        Returns:
            str: A string representation of the API Key.
        &#34;&#34;&#34;
        return self.API_Key

    def _parse_api_key(self, API_Key: str) -&gt; dict:
        &#34;&#34;&#34;
        Parses the API Key string into a dictionary.

        The API Key string should be in the format &#39;DZIENNIKSID:SDZIENNIKSID&#39;.

        Args:
            API_Key (str): The API Key string to be parsed.

        Returns:
            dict: A dictionary containing the parsed API Key, with keys &#39;DZIENNIKSID&#39; and &#39;SDZIENNIKSID&#39;.

        Raises:
            TokenKeyError: If the API Key is not in the correct format.
        &#34;&#34;&#34;
        parts = API_Key.split(&#34;:&#34;)
        if len(parts) != 2:
            raise TokenKeyError(
                &#34;API_Key must be in the format &#39;DZIENNIKSID:SDZIENNIKSID&#39;&#34;
            )
        return {&#34;DZIENNIKSID&#34;: parts[0], &#34;SDZIENNIKSID&#34;: parts[1]}

    def access_cookies(self) -&gt; RequestsCookieJar:
        &#34;&#34;&#34;
        returns CookieJar containing authorization cookies.

        Returns:
            RequestsCookieJar: A CookieJar containing the authorization cookies generated from the parsed API Key.
        &#34;&#34;&#34;
        return cookiejar_from_dict(self._parse_api_key(self.API_Key))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="librus_apix.client.Token.access_cookies"><code class="name flex">
<span>def <span class="ident">access_cookies</span></span>(<span>self) â€‘>Â requests.cookies.RequestsCookieJar</span>
</code></dt>
<dd>
<div class="desc"><p>returns CookieJar containing authorization cookies.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>RequestsCookieJar</code></dt>
<dd>A CookieJar containing the authorization cookies generated from the parsed API Key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def access_cookies(self) -&gt; RequestsCookieJar:
    &#34;&#34;&#34;
    returns CookieJar containing authorization cookies.

    Returns:
        RequestsCookieJar: A CookieJar containing the authorization cookies generated from the parsed API Key.
    &#34;&#34;&#34;
    return cookiejar_from_dict(self._parse_api_key(self.API_Key))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="librus_apix" href="index.html">librus_apix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="librus_apix.client.new_client" href="#librus_apix.client.new_client">new_client</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="librus_apix.client.Client" href="#librus_apix.client.Client">Client</a></code></h4>
<ul class="">
<li><code><a title="librus_apix.client.Client.get" href="#librus_apix.client.Client.get">get</a></code></li>
<li><code><a title="librus_apix.client.Client.get_token" href="#librus_apix.client.Client.get_token">get_token</a></code></li>
<li><code><a title="librus_apix.client.Client.post" href="#librus_apix.client.Client.post">post</a></code></li>
<li><code><a title="librus_apix.client.Client.refresh_oauth" href="#librus_apix.client.Client.refresh_oauth">refresh_oauth</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="librus_apix.client.Token" href="#librus_apix.client.Token">Token</a></code></h4>
<ul class="">
<li><code><a title="librus_apix.client.Token.access_cookies" href="#librus_apix.client.Token.access_cookies">access_cookies</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>